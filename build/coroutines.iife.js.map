{"version":3,"file":"coroutines.iife.js","sources":["../coroutines.ts"],"sourcesContent":["\n/**\n * A Coroutine is a regular [ES6 Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)\n * returned by a [generator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*).\n * \n * ```typescript\n * function* simpleCoroutine() {\n *   console.log('hello')\n *   yield\n *   console.log('world')\n * }\n * \n * let coro : Coroutine = simpleCoroutine()\n * ```\n */\nexport type Coroutine = Generator<any>\n\n/**\n * Some functions accept either a [[Coroutine]] or a function that can be called\n * with no arguments to produce a [[Coroutine]]. This enables passing `function*`\n * in addition to instantiated [[Coroutine]]s.\n * \n * ```js\n * function* namedCoroutine() { ... }\n * const sched = new coro.Schedule()\n * // invoking namedCoroutine produces a Coroutine instance\n * sched.add(namedCoroutine())\n * // function* literal is not a Coroutine instance, but can\n * // be invoked to produce one. It is a CoroutineOrFunction.\n * sched.add(function* () { ... })\n * ```\n */\nexport type CoroutineOrFunction = Coroutine | ((...any) => Coroutine)\n\n/**\n * A coroutine schedule.\n * \n * Coroutines are added to a schedule with [[add]] and all scheduled\n * coroutines are advanced with [[tick]].\n */\nexport class Schedule {\n    private coroutines: Coroutine[] = []\n    /**\n     * For debugging\n     */\n    public readonly name: string;\n\n    constructor(name = generateNewName()) {\n        this.name = name;\n    }\n\n    /**\n     * Schedules a coroutine for evaluation.\n     * \n     * Future calls to [[tick]] will run `coro` up to its next `yield` until it is completed.\n     * \n     * As a convenience if `coro` is a generator function and not a generator, it will be evaluated to produce a generator.\n     * \n     * ```js\n     * function* coroutineFunction() { ... }\n     * let schedule = new Schedule()\n     * schedule.add(coroutineFunction()) // this works\n     * schedule.add(coroutineFunction)   // so does this\n     * ```\n     * \n     * @param coro coroutine to add\n     */\n    public add(coro: CoroutineOrFunction) {\n        let c = \"next\" in coro ? coro : coro();\n        this.coroutines.push(c)\n        return c\n    }\n\n    /**\n     * Stops a single coroutine\n     * \n     * @param coro coroutine to remove\n     */\n    public remove(coro: Coroutine) {\n        this.coroutines.splice(this.coroutines.indexOf(coro), 1)\n    }\n\n    /**\n     * Discards all scheduled coroutines\n     */\n    public removeAll() {\n        this.coroutines = []\n    }\n\n    /**\n     * Advances all scheduled coroutines once.\n     * \n     * Each coroutine added with [[add]] will run up to its next `yield` statement. Finished coroutines are removed\n     * from the collection.\n     */\n    public tick() {\n        let toRemove = []\n        for (const coro of this.coroutines) {\n            let result = coro.next()\n            if (result.done) {\n                toRemove.push(coro)\n            }\n        }\n        for (const x of toRemove) {\n            this.coroutines.splice(this.coroutines.indexOf(x), 1)\n        }\n    }\n}\n\nlet generateNewName = () => Math.random().toString(36).replace(\"0.\", \"Schedule.\")\n\nif (typeof window === \"undefined\") {\n    global[\"performance\"] = require(\"perf_hooks\").performance;\n}\n\nlet _clock = () => performance.now() / 1000\n\n/**\n * Sets a new clock function.\n * \n * The clock function returns the elapsed application time in seconds. It is called by some coroutines to measure the\n * passage of time. defaults to `performance.now() / 1000`\n *\n * @param f New clock function\n */\nexport function setClock(f: () => number) {\n    _clock = f\n}\n\n/**\n * Wait for a number of seconds.\n * \n * @category Coroutine\n * \n * @param seconds How many seconds to wait\n * @param clock A function that returns the elapsed application time in seconds, defaults to the function assigned by [[setClock]]\n * @see [[setClock]]\n */\nexport function* wait(seconds: number, clock = _clock): Coroutine {\n    let startTime = clock()\n    while (clock() - startTime < seconds) {\n        yield;\n    }\n}\n\n/**\n * Wait for a number of frames.\n * \n * @category Coroutine\n * \n * @param n How many frames to wait\n */\nexport function* waitFrames(n: number): Coroutine {\n    while (n-- > 0) {\n        yield;\n    }\n}\n\n/**\n * Wait until a function `f` returns true.\n * \n * @category Coroutine\n * \n * @param f A function to execute every frame. When `f` returns truthy this coroutine completes.\n */\nexport function* waitUntil(f: (...any) => boolean): Coroutine {\n    while (!f()) {\n        yield;\n    }\n}\n\n/**\n * Wait while a function `f` returns true.\n * \n * @category Coroutine\n * \n * @param f A function to execute every frame. When `f` returns falsey this coroutine completes.\n */\nexport function* waitWhile(f: (...any) => boolean): Coroutine {\n    while (f()) {\n        yield;\n    }\n}\n\nlet advance = (c: Coroutine) => c.next()\n\nlet initialize = (c: CoroutineOrFunction) => typeof c === \"function\" ? c() : c\n\n/**\n * Returns a coroutine that waits for every coroutine of `coros` to complete.\n * \n * @category Combinator\n * @param coros The coroutines to wait for\n */\nexport function* waitAll(coros: CoroutineOrFunction[]): Coroutine {\n    let coros_ = coros.map(initialize)\n    let results = coros_.map(advance)\n    while (results.filter(r => r.done).length !== coros_.length) {\n        yield;\n        for (var i = 0; i < coros_.length; i++) {\n            let coro = coros_[i]\n            let res = results[i]\n            if (!res.done) {\n                results[i] = advance(coro)\n            }\n        }\n    }\n}\n\n/**\n * Returns a coroutine that waits for the first coroutine of `coros` to complete.\n * \n * @category Combinator\n * @param coros The coroutines to wait for\n * @returns When complete, returns the value returned by the first completed coroutine in `coros`.\n */\nexport function* waitFirst(coros: CoroutineOrFunction[]): Coroutine {\n    let coros_ = coros.map(initialize)\n    while (true) {\n        for (const c of coros_) {\n            let res = c.next()\n            if (res.done)\n                return res.value;\n        }\n        yield\n    }\n}"],"names":[],"mappings":";;;IAkCA;;;;;;UAMa,QAAQ;QAOjB,YAAY,IAAI,GAAG,eAAe,EAAE;YAN5B,eAAU,GAAgB,EAAE,CAAA;YAOhC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACpB;;;;;;;;;;;;;;;;;QAkBM,GAAG,CAAC,IAAyB;YAChC,IAAI,CAAC,GAAG,MAAM,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,EAAE,CAAC;YACvC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;YACvB,OAAO,CAAC,CAAA;SACX;;;;;;QAOM,MAAM,CAAC,IAAe;YACzB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAA;SAC3D;;;;QAKM,SAAS;YACZ,IAAI,CAAC,UAAU,GAAG,EAAE,CAAA;SACvB;;;;;;;QAQM,IAAI;YACP,IAAI,QAAQ,GAAG,EAAE,CAAA;YACjB,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;gBAChC,IAAI,MAAM,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;gBACxB,IAAI,MAAM,CAAC,IAAI,EAAE;oBACb,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;iBACtB;aACJ;YACD,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE;gBACtB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;aACxD;SACJ;KACJ;IAED,IAAI,eAAe,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,WAAW,CAAC,CAAA;IAEjF,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;QAC/B,MAAM,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,WAAW,CAAC;KAC7D;IAED,IAAI,MAAM,GAAG,MAAM,WAAW,CAAC,GAAG,EAAE,GAAG,IAAI,CAAA;IAE3C;;;;;;;;aAQgB,QAAQ,CAAC,CAAe;QACpC,MAAM,GAAG,CAAC,CAAA;IACd,CAAC;IAED;;;;;;;;;cASiB,IAAI,CAAC,OAAe,EAAE,KAAK,GAAG,MAAM;QACjD,IAAI,SAAS,GAAG,KAAK,EAAE,CAAA;QACvB,OAAO,KAAK,EAAE,GAAG,SAAS,GAAG,OAAO,EAAE;YAClC,KAAK,CAAC;SACT;IACL,CAAC;IAED;;;;;;;cAOiB,UAAU,CAAC,CAAS;QACjC,OAAO,CAAC,EAAE,GAAG,CAAC,EAAE;YACZ,KAAK,CAAC;SACT;IACL,CAAC;IAED;;;;;;;cAOiB,SAAS,CAAC,CAAsB;QAC7C,OAAO,CAAC,CAAC,EAAE,EAAE;YACT,KAAK,CAAC;SACT;IACL,CAAC;IAED;;;;;;;cAOiB,SAAS,CAAC,CAAsB;QAC7C,OAAO,CAAC,EAAE,EAAE;YACR,KAAK,CAAC;SACT;IACL,CAAC;IAED,IAAI,OAAO,GAAG,CAAC,CAAY,KAAK,CAAC,CAAC,IAAI,EAAE,CAAA;IAExC,IAAI,UAAU,GAAG,CAAC,CAAsB,KAAK,OAAO,CAAC,KAAK,UAAU,GAAG,CAAC,EAAE,GAAG,CAAC,CAAA;IAE9E;;;;;;cAMiB,OAAO,CAAC,KAA4B;QACjD,IAAI,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;QAClC,IAAI,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAA;QACjC,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE;YACzD,KAAK,CAAC;YACN,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpC,IAAI,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;gBACpB,IAAI,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;gBACpB,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;oBACX,OAAO,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;iBAC7B;aACJ;SACJ;IACL,CAAC;IAED;;;;;;;cAOiB,SAAS,CAAC,KAA4B;QACnD,IAAI,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;QAClC,OAAO,IAAI,EAAE;YACT,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE;gBACpB,IAAI,GAAG,GAAG,CAAC,CAAC,IAAI,EAAE,CAAA;gBAClB,IAAI,GAAG,CAAC,IAAI;oBACR,OAAO,GAAG,CAAC,KAAK,CAAC;aACxB;YACD,KAAK,CAAA;SACR;IACL;;;;;;;;;;;;;;;;;;;"}